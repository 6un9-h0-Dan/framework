<?php
/**
 * Spiral Framework.
 *
 * @license   MIT
 * @author    Anton Titov (Wolfy-J)
 * @copyright Â©2009-2015
 */
namespace Spiral\Components\Http;

use Psr\Http\Message\ResponseInterface;
use Spiral\Components\Debug\Snapshot;
use Spiral\Core\Component;
use Spiral\Core\Core;
use Spiral\Core\Dispatcher\ClientException;
use Spiral\Core\DispatcherInterface;

class HttpDispatcher extends Component implements DispatcherInterface
{
    /**
     * Required traits.
     */
    use Component\SingletonTrait,
        Component\LoggerTrait,
        Component\EventsTrait,
        Component\ConfigurableTrait;

    /**
     * Declares to IoC that component instance should be treated as singleton.
     */
    const SINGLETON = 'http';

    /**
     * Core instance.
     *
     * @invisible
     * @var Core
     */
    protected $core = null;

    /**
     * Original server request generated by spiral while starting HttpDispatcher.
     *
     * @var Request
     */
    protected $request = null;

    /**
     * Set of middleware layers builded to handle incoming Request and return Response. Middleware
     * can be represented as class, string (DI) or array (callable method). HttpDispatcher layer
     * middlewares will be called in start() method. Use add() method to register more middlewares
     * while bootstrapping application.
     *
     * @var array|MiddlewareInterface[]
     */
    protected $middleware = array();

    /**
     * New HttpDispatcher instance.
     *
     * @param Core $core
     */
    public function __construct(Core $core)
    {
        $this->core = $core;
        $this->config = $core->loadConfig('http');
        $this->middleware = $this->config['middleware'];
    }

    /**
     * Register new HttpDispatcher level middleware. Calling this method will have effect only
     * before HttpDispatcher->start() method executed.
     *
     * @param string|callable|MiddlewareInterface $middleware
     * @return static
     */
    public function add($middleware)
    {
        $this->middleware[] = $middleware;

        return $this;
    }

    /**
     * Letting dispatcher to control application flow and functionality.
     *
     * @param Core $core
     */
    public function start(Core $core)
    {
        $this->request = Request::castServerRequest();

        $pipeline = new MiddlewarePipe($this->middleware);
        $response = $pipeline->target(array($this, 'perform'))->run($this->request, $this);

        //Use $event->object->getRequest() to access original request
        $this->dispatch($this->event('dispatch', $response));
    }

    /**
     * Get initial request generated by HttpDispatcher. This is untouched request object, all
     * cookies will be encrypted and other values will not be pre-processed.
     *
     * @return Request|null
     */
    public function getRequest()
    {
        return $this->request;
    }

    /**
     * Execute given request and return response. Request Uri will be passed thought Http routes
     * to find appropriate endpoint. By default this method will be called at the end of middleware
     * pipeline inside HttpDispatcher->start() method, however method can be called manually with
     * custom or altered request instance.
     *
     * Every request passed to perform method will be registered in Container scope under "request"
     * and class name binding.
     *
     * @param Request $request
     * @return array|Response
     * @throws ClientException
     * @throws \Spiral\Core\CoreException
     */
    public function perform(Request $request)
    {
        $parentRequest = $this->core->getBinding('request');

        //Creating scope
        $this->core->bind('request', $request);
        $this->core->bind(get_class($request), $request);

        ob_start();
        $response = $this->core->callAction('Controllers\HomeController', 'index');
        $plainOutput = ob_get_clean();

        $this->core->removeBinding(get_class($request));
        $this->core->removeBinding('request');

        if (!empty($parentRequest))
        {
            //Restoring scope
            $this->core->bind('request', $parentRequest);
            $this->core->bind(get_class($parentRequest), $parentRequest);
        }

        return $this->wrapResponse($response, $plainOutput);
    }

    protected function wrapResponse($response, $plainOutput = '')
    {
        if ($response instanceof ResponseInterface)
        {
            $plainOutput && $response->getBody()->write($plainOutput);

            return $response;
        }

        if (is_array($response) || $response instanceof \JsonSerializable)
        {
            if (is_array($response) && $plainOutput)
            {
                $response['plainOutput'] = $plainOutput;
            }

            return new Response(json_encode($response), 200, array(
                'Content-Type' => 'application/json'
            ));
        }

        return new Response($response . $plainOutput);
    }

    /**
     * Dispatch provided request to client. Application will stop after this method call.
     *
     * @param ResponseInterface $response
     */
    public function dispatch(ResponseInterface $response)
    {
        while (ob_get_level())
        {
            ob_get_clean();
        }

        $statusHeader = "HTTP/{$response->getProtocolVersion()} {$response->getStatusCode()}";
        header(rtrim("{$statusHeader} {$response->getReasonPhrase()}"));

        //Receive all headers but not cookies
        foreach ($response->getHeaders() as $header => $values)
        {
            $replace = true;
            foreach ($values as $value)
            {
                header("{$header}: {$value}", $replace);
                $replace = false;
            }
        }

        //Spiral request stores cookies separately with headers to make them easier to send
        if ($response instanceof Response)
        {
            foreach ($response->getCookies() as $cookie)
            {
                //TODO: Default cookie domain!
                setcookie(
                    $cookie->getName(),
                    $cookie->getValue(),
                    $cookie->getExpire(),
                    $cookie->getPath(),
                    $cookie->getDomain(),
                    $cookie->getSecure(),
                    $cookie->getHttpOnly()
                );
            }
        }

        if ($response->getStatusCode() == 204)
        {
            return;
        }

        $stream = $response->getBody();

        // I need self sending requests in future.
        if (!$stream->isSeekable())
        {
            echo (string)$stream;
        }
        else
        {
            //Use stream_copy_to_stream() somehow
            ob_implicit_flush(true);
            $stream->rewind();
            while (!$stream->eof())
            {
                echo $stream->read(1024);
            }
        }
    }

    /**
     * Every dispatcher should know how to handle exception snapshot provided by Debugger.
     *
     * @param Snapshot $snapshot
     * @return mixed
     */
    public function handleException(Snapshot $snapshot)
    {
        if ($snapshot->getException() instanceof ClientException)
        {
            //Simply showing something
            //$this->dispatch(new Response('ERROR VIEW LAYOUT IF PRESENTED', $snapshot->getException()->getCode()));
        }

        //TODO: hide snapshot based on config
        $this->dispatch(new Response($snapshot->renderSnapshot(), 500));
    }
}