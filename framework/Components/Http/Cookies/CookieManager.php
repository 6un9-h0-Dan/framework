<?php
/**
 * Spiral Framework.
 *
 * @license   MIT
 * @author    Anton Titov (Wolfy-J)
 * @copyright Â©2009-2015
 */
namespace Spiral\Components\Http\Cookies;

use Psr\Http\Message\ResponseInterface;
use Spiral\Components\Encrypter\DecryptionException;
use Spiral\Components\Encrypter\Encrypter;
use Spiral\Components\Encrypter\EncrypterException;
use Spiral\Components\Http\CsrfChecker;
use Spiral\Components\Http\MiddlewareInterface;
use Spiral\Components\Http\MiddlewareTrait;
use Spiral\Components\Http\Request;
use Spiral\Components\Http\Response;
use Spiral\Core\Component;

class CookieManager extends Component implements MiddlewareInterface
{
    /**
     * Required traits.
     */
    use Component\SingletonTrait, MiddlewareTrait;

    /**
     * Declares to IoC that component instance should be treated as singleton.
     */
    const SINGLETON = 'cookies';

    /**
     * Cookie names should never be encrypted or decrypted.
     *
     * @var array
     */
    protected $exclude = array(
        CsrfChecker::TOKEN_NAME
    );

    /**
     * Encrypter component.
     *
     * @var Encrypter
     */
    protected $encrypter = null;

    /**
     * Cookies has to be send (specified via global scope).
     *
     * @var CookieInterface[]
     */
    protected $scheduled = array();

    /**
     * New instance of cookie manager.
     *
     * @param Encrypter $encrypter
     */
    public function __construct(Encrypter $encrypter)
    {
        $this->encrypter = $encrypter;
    }

    /**
     * Handle request generate response. Middleware used to alter incoming Request and/or Response
     * generated by inner pipeline layers.
     *
     * @param Request     $request Server request instance.
     * @param \Closure    $next    Next middleware/target.
     * @param object|null $context Pipeline context, can be HttpDispatcher, Route or module.
     * @return Response
     */
    public function handle(Request $request, \Closure $next = null, $context = null)
    {
        $request = $this->decryptCookies($request);

        /**
         * @var Response $response
         */
        $response = $next($request);

        return $this->encryptCookies($response);
    }

    /**
     * Unpack incoming cookies and decrypt their content.
     *
     * @param Request $request
     * @return Request
     */
    protected function decryptCookies(Request $request)
    {
        $altered = false;
        $cookies = $request->getCookieParams();
        foreach ($cookies as $name => $cookie)
        {
            if (in_array($name, $this->exclude))
            {
                continue;
            }

            $altered = true;

            try
            {
                $cookies[$name] = $this->encrypter->decrypt($cookie);
            }
            catch (DecryptionException $exception)
            {
                $cookies[$name] = null;
            }
        }

        return $altered ? $request->withCookieParams($cookies) : $request;
    }

    /**
     * Pack outcoming cookies with encrypted value.
     *
     * @param ResponseInterface $response
     * @return ResponseInterface|Response
     * @throws EncrypterException
     */
    protected function encryptCookies(ResponseInterface $response)
    {
        if (!$response instanceof Response)
        {
            return $response;
        }

        if (($cookies = $response->getCookies()) || !empty($this->scheduled))
        {
            /**
             * @var CookieInterface[] $cookies
             */
            $cookies = array_merge($cookies, $this->scheduled);
            foreach ($cookies as $name => $cookie)
            {
                if (in_array($cookie->getName(), $this->exclude))
                {
                    continue;
                }

                $cookies[$name] = $cookie->withValue($this->encrypter->encrypt($cookie->getValue()));
            }

            $this->scheduled = array();

            //Overwriting cookies
            return $response->withCookies($cookies);
        }

        return $response;
    }
}